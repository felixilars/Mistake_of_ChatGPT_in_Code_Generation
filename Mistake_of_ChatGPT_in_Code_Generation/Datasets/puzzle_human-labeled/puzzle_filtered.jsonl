{"problem_func": "from typing import List\ndef f(x, nums=[12, 25, 37, 50, 62, 75, 87, 99]) -> bool:\n    return x >= (functools.reduce(lambda a, b: a | b, (n >> x for n in nums)))", "solution_func": "def g(nums=[12, 25, 37, 50, 62, 75, 87, 99]):\n    return functools.reduce(lambda a, b: a | b, (n >> 0 for n in nums)).bit_length()", "description": "Find the solution: x (an integer) that should be the smallest number of right shifts required to make all the bits in the given list of integers `nums` zero.", "unique_id": "aces_elm_s5_p2811", "name": "puzzle_1"}
{"problem_func": "import random\n\ndef f(max_consecutive_wins, p=0.5, k=3):\n    consecutive_wins = 0\n    for _ in range(10000):\n        wins = 0\n        while True:\n            if random.random() < p:\n                wins += 1\n                if wins == k:\n                    consecutive_wins = max(consecutive_wins, wins)\n                    break\n            else:\n                wins = 0\n    return max_consecutive_wins == consecutive_wins", "solution_func": "def g(p=0.5, k=3):\n    max_consecutive_wins = 0\n    while True:\n        if f(max_consecutive_wins, p, k):\n            return max_consecutive_wins\n        max_consecutive_wins += 1", "description": "Find the solution: max_consecutive_wins (an integer) that should represent the maximum number of consecutive wins in a series of coin flips, where each flip has a probability p of winning and the goal is to reach k consecutive wins, such that the solution satisfies the condition that the maximum number of consecutive wins in 10,000 simulations is equal to max_consecutive_wins.", "unique_id": "aces_elm_s5_p3439", "name": "puzzle_2"}
{"problem_func": "def f(min_ops, nums=[5, 2, 8, 1, 4]) -> bool:\n    def min_ops_to_sort(nums):\n        ops = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if nums[i] > nums[j]:\n                    ops += 1\n        return ops == min_ops\n    return min_ops_to_sort(nums)", "solution_func": "def g(nums=[5, 2, 8, 1, 4]):\n    ops = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            if nums[i] > nums[j]:\n                ops += 1\n    return ops", "description": "Find the solution: min_ops (an integer) that should represent the minimum number of operations required to sort the given list of integers `nums` in ascending order, where an operation is defined as a swap of two elements in the list.", "unique_id": "aces_elm_s5_p1309", "name": "puzzle_3"}
{"problem_func": "def f(max_circles: int, points=[(0, 0), (0, 1), (1, 0), (1, 1)]) -> bool:\n    def is_circle(p1, p2, p3):\n        return not (p1 == p2 or p1 == p3 or p2 == p3)\n    def max_circles_points(points):\n        max_circles = 0\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                for k in range(j+1, len(points)):\n                    if is_circle(points[i], points[j], points[k]):\n                        max_circles += 1\n        return max_circles\n    return max_circles == max_circles_points(points)", "solution_func": "def g(points=[(0, 0), (0, 1), (1, 0), (1, 1)]):\n    def is_circle(p1, p2, p3):\n        return not (p1 == p2 or p1 == p3 or p2 == p3)\n    def max_circles_points(points):\n        max_circles = 0\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                for k in range(j+1, len(points)):\n                    if is_circle(points[i], points[j], points[k]):\n                        max_circles += 1\n        return max_circles\n    return max_circles_points(points)", "description": "Find the solution: max_circles (an integer) that should be the maximum number of unique circles that can be formed using the given list of points (a list of 2D coordinates), where a circle is defined by three distinct points.", "unique_id": "aces_elm_s5_p3412", "name": "puzzle_4"}
{"problem_func": "from typing import List\nimport random\n\ndef f(rectangles: List[List[tuple]], target_area=1000) -> bool:\n    total_area = 0\n    rectangle_hashes = set()\n    for rectangle in rectangles:\n        top_left, bottom_right = rectangle\n        x1, y1 = top_left\n        x2, y2 = bottom_right\n        total_area += (x2 - x1) * (y2 - y1)\n        rectangle_hash = hash((top_left, bottom_right))\n        if rectangle_hash in rectangle_hashes:\n            return False\n        rectangle_hashes.add(rectangle_hash)\n    return total_area >= target_area", "solution_func": "def g(target_area=1000):\n    rectangles = []\n    num_rectangles = target_area // 100\n    for _ in range(num_rectangles):\n        top_left = (random.randint(-100, 100), random.randint(-100, 100))\n        bottom_right = (random.randint(top_left[0], 200), random.randint(top_left[1], 200))\n        rectangles.append([top_left, bottom_right])\n    return rectangles", "description": "Find the solution: rectangles (a list of rectangles, each defined by two tuples representing the top-left and bottom-right coordinates) that should have a total area of at least the target area (1000 by default) without any duplicate rectangles.", "unique_id": "aces_elm_s5_p423", "name": "puzzle_5"}
{"problem_func": "def f(max_distance: int, arr=[1, 2, 3, 2, 1, 4, 5, 6]) -> bool:\n    def max_distance_elements(arr):\n        max_distance = 0\n        hash_table = {}\n        for i, num in enumerate(arr):\n            if num in hash_table:\n                max_distance = max(max_distance, i - hash_table[num])\n            hash_table[num] = i\n        return max_distance\n    return max_distance_elements(arr) == max_distance", "solution_func": "def g(arr=[1, 2, 3, 2, 1, 4, 5, 6]):\n    def max_distance_elements(arr):\n        max_distance = 0\n        hash_table = {}\n        for i, num in enumerate(arr):\n            if num in hash_table:\n                max_distance = max(max_distance, i - hash_table[num])\n            hash_table[num] = i\n        return max_distance\n    return max_distance_elements(arr)", "description": "Find the solution: max_distance (an integer) that should be the maximum distance between any two occurrences of the same element in the given array arr (a list of integers), such that the maximum distance between any two occurrences of the same element in the array is equal to max_distance.", "unique_id": "aces_elm_s5_p617", "name": "puzzle_6"}
{"problem_func": "def f(min_ops, nums=[4, 2, 7, 1, 3, 5, 6]) -> bool:\n    def insertion_sort(nums, min_ops):\n        if min_ops == 0:\n            return nums\n        for i in range(1, len(nums)):\n            key = nums[i]\n            j = i - 1\n            while j >= 0 and nums[j] > key:\n                nums[j + 1] = nums[j]\n                j -= 1\n            nums[j + 1] = key\n            min_ops -= 1\n            if min_ops == 0:\n                return nums\n        return insertion_sort(nums, min_ops)\n    return insertion_sort(nums, min_ops) == sorted(nums)", "solution_func": "def g(nums=[4, 2, 7, 1, 3, 5, 6]):\n    min_ops = 0\n    for i in range(1, len(nums)):\n        key = nums[i]\n        j = i - 1\n        while j >= 0 and nums[j] > key:\n            nums[j + 1] = nums[j]\n            j -= 1\n            min_ops += 1\n        nums[j + 1] = key\n    return min_ops", "description": "Find the solution: min_ops (integer) that should be the minimum number of operations required to sort the given list `nums` (list of integers) using the insertion sort algorithm, such that the partially sorted list after `min_ops` operations is equal to the fully sorted list.", "unique_id": "aces_elm_s5_p671", "name": "puzzle_7"}
{"problem_func": "def f(max_profit: int, prices=[10, 20, 15, 30, 40], max_transactions=2) -> bool:\n    dp = [[0] * (max_transactions + 1) for _ in range(len(prices))]\n    for i in range(1, len(prices)):\n        max_profit = 0\n        for j in range(1, min(i, max_transactions) + 1):\n            max_profit = max(max_profit, dp[i - 1][j - 1] + prices[i] - prices[i - 1])\n            dp[i][j] = max(dp[i - 1][j], max_profit)\n    return dp[-1][-1] == max_profit", "solution_func": "def g(prices=[10, 20, 15, 30, 40], max_transactions=2):\n    dp = [[0] * (max_transactions + 1) for _ in range(len(prices))]\n    for i in range(1, len(prices)):\n        max_profit = 0\n        for j in range(1, min(i, max_transactions) + 1):\n            max_profit = max(max_profit, dp[i - 1][j - 1] + prices[i] - prices[i - 1])\n            dp[i][j] = max(dp[i - 1][j], max_profit)\n    return dp[-1][-1]", "description": "Find the solution: max_profit (an integer) that should represent the maximum possible profit that can be achieved by buying and selling stocks at most max_transactions times, given a list of stock prices and a maximum number of transactions.", "unique_id": "aces_elm_s5_p2617", "name": "puzzle_8"}
{"problem_func": "def f(min_ops: int, nums=[1, 2, 3, 4, 5]) -> bool:\n    ops = 0\n    while len(set(nums)) > 1:\n        max_val = max(nums)\n        min_val = min(nums)\n        nums[nums.index(max_val)] = min_val\n        ops += 1\n    return ops == min_ops", "solution_func": "def g(nums=[1, 2, 3, 4, 5]):\n    min_ops = 0\n    while len(set(nums)) > 1:\n        max_val = max(nums)\n        min_val = min(nums)\n        nums[nums.index(max_val)] = min_val\n        min_ops += 1\n    return min_ops", "description": "Find the solution: min_ops (integer) that should be the minimum number of operations required to make all elements in the list `nums` (a list of integers) equal by repeatedly replacing the maximum value with the minimum value.", "unique_id": "aces_elm_s5_p2067", "name": "puzzle_9"}
{"problem_func": "import math\nfrom itertools import combinations\n\ndef f(min_sides, points=[(0, 0), (1, 0), (1, 1), (0, 1)], max_points=4, max_area=1.0) -> bool:\n    min_s = float('inf')\n    for r in range(1, max_points+1):\n        for combo in combinations(points, r):\n            area = 0\n            for i in range(len(combo)):\n                x1, y1 = combo[i]\n                x2, y2 = combo[(i+1)%len(combo)]\n                area += (x1*y2 - x2*y1)\n            if area <= max_area * 2:\n                min_s = min(min_s, len(combo))\n    return min_s == min_sides", "solution_func": "def g(points=[(0, 0), (1, 0), (1, 1), (0, 1)], max_points=4, max_area=1.0):\n    min_s = float('inf')\n    for r in range(1, max_points+1):\n        for combo in combinations(points, r):\n            area = 0\n            for i in range(len(combo)):\n                x1, y1 = combo[i]\n                x2, y2 = combo[(i+1)%len(combo)]\n                area += (x1*y2 - x2*y1)\n            if area <= max_area * 2:\n                min_s = min(min_s, len(combo))\n    return min_s", "description": "Find the solution: min_sides (an integer) that should be the minimum number of points required to form a polygon with an area not exceeding max_area, given a list of points (2D coordinates) and a maximum number of points to consider.", "unique_id": "aces_elm_s5_p3683", "name": "puzzle_10"}
{"problem_func": "def f(max_common: int, arr1=[1, 2, 3, 4, 5], arr2=[4, 5, 6, 7, 8]) -> bool:\n    set1 = set(arr1)\n    set2 = set(arr2)\n    common_elements = set1 & set2\n    return len(common_elements) == max_common", "solution_func": "def g(arr1=[1, 2, 3, 4, 5], arr2=[4, 5, 6, 7, 8]):\n    set1 = set(arr1)\n    set2 = set(arr2)\n    common_elements = set1 & set2\n    return len(common_elements)", "description": "Find the solution: max_common (an integer) that should be the number of common elements between two lists arr1 and arr2.", "unique_id": "aces_elm_s5_p1863", "name": "puzzle_11"}
{"problem_func": "def f(max_subset_sum, A=[1, 2, 3, 4, 5], L=10) -> bool:\n    dp = [0] * (L + 1)\n    for i in range(len(A)):\n        for j in range(L, A[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - A[i]] + A[i])\n    return dp[L] == max_subset_sum", "solution_func": "def g(A=[1, 2, 3, 4, 5], L=10):\n    dp = [0] * (L + 1)\n    for i in range(len(A)):\n        for j in range(L, A[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - A[i]] + A[i])\n    return dp[L]", "description": "Find the solution: max_subset_sum (an integer) that should be the maximum sum of a subset of the list A (a list of integers) such that the sum does not exceed L (an integer).", "unique_id": "aces_elm_s5_p3386", "name": "puzzle_12"}
{"problem_func": "from typing import List\n\ndef f(groups: List[List[int]], n=10, target_sum=20, k=3) -> bool:\n    for group in groups:\n        if len(group) > k or sum(group) != target_sum:\n            return False\n    return True", "solution_func": "def g(n=10, target_sum=20, k=3):\n    def backtrack(n, target_sum, k, groups):\n        if n == 0:\n            return [groups]\n        paths = []\n        for i in range(1, min(k, n) + 1):\n            if i * target_sum <= n:\n                paths.extend(backtrack(n - i, target_sum, k, groups + [list(range(i, 0, -1))]))\n        return paths\n    return backtrack(n, target_sum, k, [])", "description": "Find the solution: groups (lists of integers) that should be divided into sublists of length not more than k and sum equal to target_sum, given n as the total number of elements.", "unique_id": "aces_elm_s5_p523", "name": "puzzle_13"}
{"problem_func": "def f(p: list) -> bool:\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    for i in range(len(p) - 1):\n        if not is_prime(p[i] + p[i+1]):\n            return False\n    return True", "solution_func": "def g():\n    def backtrack(p, nums):\n        if len(p) == 7:\n            return p\n        for num in nums:\n            p.append(num)\n            nums.remove(num)\n            result = backtrack(p, nums)\n            if result:\n                return result\n            p.pop()\n            nums.add(num)\n        return None\n    nums = set(range(1, 8))\n    return backtrack([], nums)", "description": "Find the solution: p (a list of integers) that should contain consecutive elements whose sum is a prime number.", "unique_id": "aces_elm_s5_p139", "name": "puzzle_14"}
{"problem_func": "from typing import List\ndef f(ls: List[int], n=1000) -> bool:\n    return ls[0] * ls[1] * ls[2] == n", "solution_func": "def g(n=1000):\n    for a in range(1, n):\n        for b in range(a, n):\n            if n % (a * b) == 0:\n                c = n // (a * b)\n                return [a, b, c]", "description": "Find the solution: ls (a list of three integers) that should contain three numbers whose product equals the given number n (an integer with a default value of 1000).", "unique_id": "aces_elm_s5_p232", "name": "puzzle_15"}
{"problem_func": "from typing import List\n\ndef f(min_partitions: List[List[int]], arr: List[int] = [1, 2, 3, 4, 5], m: int = 10) -> bool:\n    def backtrack(start, end, partitions):\n        if sum(arr[start:end]) > m:\n            return []\n        min_partitions = []\n        for i in range(start, end):\n            min_partitions = min(min_partitions, [arr[i:i + 1]] + backtrack(i + 1, end, partitions))\n        return min_partitions\n    return min_partitions == backtrack(0, len(arr), [])", "solution_func": "def g(arr: List[int] = [1, 2, 3, 4, 5], m: int = 10):\n    min_partitions = []\n    for i in range(len(arr)):\n        min_partitions = min(min_partitions, [arr[i:i + 1]])\n    return min_partitions", "description": "Find the solution: min_partitions (a list of lists of integers) that should partition the input array `arr` (a list of integers) into the minimum number of subarrays such that the sum of each subarray does not exceed `m` (an integer).", "unique_id": "aces_elm_s5_p2885", "name": "puzzle_16"}
{"problem_func": "def f(n: int) -> bool:\n    def sum_digits(x):\n        return sum(int(digit) for digit in str(x))\n    return sum_digits(n) == sum_digits(n**2)", "solution_func": "def g():\n    n = 1\n    while True:\n        if sum_digits(n) == sum_digits(n**2):\n            return n\n        n += 1\n\ndef sum_digits(x):\n    return sum(int(digit) for digit in str(x))", "description": "Find the solution: n (an integer) that should have the property where the sum of its digits is equal to the sum of the digits of its square.", "unique_id": "aces_elm_s5_p702", "name": "puzzle_17"}
{"problem_func": "import itertools\n\ndef f(sample_space: set, coins=3, flips=2) -> bool:\n    possible_outcomes = 2 ** (coins * flips)\n    return len(sample_space) == possible_outcomes", "solution_func": "def g(coins=3, flips=2):\n    sample_space = set()\n    for outcome in itertools.product([0, 1], repeat=coins * flips):\n        sample_space.add(outcome)\n    return sample_space", "description": "Find the solution: sample_space (a set of tuples) that should contain all possible outcomes of flipping a certain number of coins (coins=3) a certain number of times (flips=2), such that the total number of outcomes in the sample space is equal to the total possible outcomes (2^(coins*flips)).", "unique_id": "aces_elm_s5_p326", "name": "puzzle_18"}
{"problem_func": "def f(min_time: int, durations=[10, 20, 30], speeds=[1, 2, 3]) -> bool:\n    durations.sort()\n    speeds.sort(reverse=True)\n    total_time = 0\n    for d, s in zip(durations, speeds):\n        total_time += d / s\n    return total_time == min_time", "solution_func": "def g(durations=[10, 20, 30], speeds=[1, 2, 3]):\n    durations.sort()\n    speeds.sort(reverse=True)\n    total_time = 0\n    for d, s in zip(durations, speeds):\n        total_time += d / s\n    return total_time", "description": "Find the solution: min_time (an integer) that should be the minimum total time required to complete all tasks when each task's duration is divided by its corresponding speed, given lists of durations and speeds.", "unique_id": "aces_elm_s5_p2620", "name": "puzzle_19"}
{"problem_func": "import math\n\ndef f(max_circles, circle=(0, 0, 10), circles=[(0, 0, 1), (1, 1, 2), (2, 2, 3)]) -> bool:\n    packed = set()\n    for cx, cy, cr in circles:\n        if math.hypot(cx - circle[0], cy - circle[1]) + cr <= circle[2]:\n            packed.add((cx, cy, cr))\n    return len(packed) == max_circles", "solution_func": "def g(circle=(0, 0, 10), circles=[(0, 0, 1), (1, 1, 2), (2, 2, 3)]):\n    packed = set()\n    for cx, cy, cr in circles:\n        if math.hypot(cx - circle[0], cy - circle[1]) + cr <= circle[2]:\n            packed.add((cx, cy, cr))\n    max_circles = len(packed)\n    return max_circles", "description": "Find the solution: max_circles (an integer) that should be the maximum number of circles from the list of circles (a list of tuples representing the center coordinates and radius of each circle) that can be packed inside a given circle (a tuple representing the center coordinates and radius of the circle) without overlapping.", "unique_id": "aces_elm_s5_p4322", "name": "puzzle_20"}
{"problem_func": "def f(Sudoku: list) -> bool:\n    for i in range(9):\n        row = [Sudoku[i][j] for j in range(9)]\n        if set(row) != set(range(1, 10)):\n            return False\n    for i in range(9):\n        col = [Sudoku[j][i] for j in range(9)]\n        if set(col) != set(range(1, 10)):\n            return False\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            box = [Sudoku[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if set(box) != set(range(1, 10)):\n                return False\n    return True", "solution_func": "def g():\n    Sudoku = [[5, 3, 0, 0, 7, 0, 0, 0, 0],\n              [6, 0, 0, 1, 9, 5, 0, 0, 0],\n              [0, 9, 8, 0, 0, 0, 0, 6, 0],\n              [8, 0, 0, 0, 6, 0, 0, 0, 3],\n              [4, 0, 0, 8, 0, 3, 0, 0, 1],\n              [7, 0, 0, 0, 2, 0, 0, 0, 6],\n              [0, 6, 0, 0, 0, 0, 2, 8, 0],\n              [0, 0, 0, 4, 1, 9, 0, 0, 5],\n              [0, 0, 0, 0, 8, 0, 0, 7, 9]]\n    return Sudoku", "description": "Find the solution: 9x9 Sudoku grid that should contain the numbers 1-9 in each row, column, and 3x3 sub-grid without repeating any number.", "unique_id": "aces_elm_s5_p807", "name": "puzzle_21"}
{"problem_func": "from typing import List, Tuple\n\ndef f(routes: List[List[Tuple[int, int]]]) -> bool:\n    cities = set()\n    for route in routes:\n        assert len(route) >= 2\n        for i in range(len(route) - 1):\n            x1, y1 = route[i]\n            x2, y2 = route[i + 1]\n            assert abs(x1 - x2) + abs(y1 - y2) == 1\n            cities.add((x1, y1))\n            cities.add((x2, y2))\n    return len(cities) == 10", "solution_func": "def g():\n    import random\n    routes = []\n    cities = [(random.randint(0, 19), random.randint(0, 19)) for _ in range(10)]\n    for _ in range(10):\n        route = [cities[_]]\n        while True:\n            x, y = route[-1]\n            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n            random.shuffle(directions)\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < 20 and 0 <= ny < 20 and (nx, ny) not in route:\n                    route.append((nx, ny))\n                    break\n            else:\n                break\n        routes.append(route)\n    return routes", "description": "Find the solution: routes (a list of lists of 2D coordinates) that should form a path visiting exactly 10 distinct cities, where each city is a 2D coordinate and each route is a sequence of adjacent cities (i.e., the Manhattan distance between consecutive cities in a route is 1).", "unique_id": "aces_elm_s5_p315", "name": "puzzle_22"}
{"problem_func": "import itertools\ndef f(max_distance: int, arr=[1, 2, 3, 4, 5]) -> bool:\n    circular_arr = arr + arr[:-1]\n    max_dist = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(circular_arr)):\n            if circular_arr[i] == circular_arr[j]:\n                dist = min(j-i, len(circular_arr)-j+i)\n                max_dist = max(max_dist, dist)\n    return max_dist == max_distance", "solution_func": "def g(arr=[1, 2, 3, 4, 5]):\n    circular_arr = arr + arr[:-1]\n    max_dist = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(circular_arr)):\n            if circular_arr[i] == circular_arr[j]:\n                dist = min(j-i, len(circular_arr)-j+i)\n                max_dist = max(max_dist, dist)\n    return max_dist", "description": "Find the solution: max_distance (an integer) that should be the maximum distance between any two identical elements in a circular array arr (a list of integers), considering the array as circular by concatenating it with itself.", "unique_id": "aces_elm_s5_p4718", "name": "puzzle_23"}
{"problem_func": "from typing import List \n\ndef f(subs: List[List[int]], nums=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]) -> bool:\n    def count_prime_factors(n):\n        i = 2\n        count = 0\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                count += 1\n        if n > 1:\n            count += 1\n        return count\n    return all((sum((nums[i] >> j & 1 for i, j in sub)) == count_prime_factors(n) for sub, n in zip(subs, nums)))", "solution_func": "def g(nums=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]):\n    # Greedy algorithm to find the subs\n    subs = []\n    for i in range(len(nums)):\n        sub = []\n        for j in range(i + 1, len(nums)):\n            if sum((nums[i] >> k & 1 for k in range(nums[i].bit_length()))) == sum((nums[j] >> k & 1 for k in range(nums[j].bit_length()))):\n                sub.append([i, j])\n        subs.append(sub)\n    return subs", "description": "Find the solution: subs (a list of lists of integers) that should contain subsets of indices of the list `nums` (a list of prime numbers) such that the sum of the binary representations of the corresponding prime numbers at these indices equals the count of prime factors for each prime number in `nums`.", "unique_id": "aces_elm_s5_p639", "name": "puzzle_24"}
{"problem_func": "def f(max_prime_gcd: int, nums=[10, 15, 20, 30, 45]) -> bool:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    return all(gcd(num1, num2) <= max_prime_gcd for num1 in nums for num2 in nums if is_prime(num1) and is_prime(num2))", "solution_func": "def g(nums=[10, 15, 20, 30, 45]):\n    max_prime_gcd = 0\n    for num1 in nums:\n        for num2 in nums:\n            if all(num1 % i != 0 for i in range(2, int(num1 ** 0.5) + 1)) and all(num2 % i != 0 for i in range(2, int(num2 ** 0.5) + 1)):\n                gcd_num = num1\n                for i in range(2, min(num1, num2) + 1):\n                    while num1 % i == 0 and num2 % i == 0:\n                        gcd_num = i\n                        i += 1\n                max_prime_gcd = max(max_prime_gcd, gcd_num)\n    return max_prime_gcd", "description": "Find the solution: max_prime_gcd (an integer) that should be the greatest common divisor of the given list of integers `nums` that is also a prime number.", "unique_id": "aces_elm_s5_p1763", "name": "puzzle_25"}
{"problem_func": "def f(schedule, dependencies=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 1]]) -> bool:\n    task_deps = {}\n    for dep in dependencies:\n        if dep[0] not in task_deps:\n            task_deps[dep[0]] = []\n        task_deps[dep[0]].append(dep[1])\n    for task_list in schedule:\n        for i in range(len(task_list) - 1):\n            if task_list[i] in task_deps and task_list[i + 1] not in task_deps[task_list[i]]:\n                return False\n    return True", "solution_func": "def g(dependencies=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 1]]):\n    tasks = set(i for dep in dependencies for i in dep)\n    schedule = []\n    while tasks:\n        task = tasks.pop()\n        schedule.append([task])\n        for dep in dependencies:\n            if dep[0] == task:\n                tasks.discard(dep[1])\n    return schedule", "description": "Find the solution: schedule (a list of lists of task IDs) that should contain tasks in an order such that each task is executed after all its dependent tasks, given the dependencies (a list of lists where each sublist contains two task IDs, the first being dependent on the second).", "unique_id": "aces_elm_s5_p794", "name": "puzzle_26"}
{"problem_func": "from collections import defaultdict\ndef f(days: int, tasks=[('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'D'), ('D', 'E')]) -> bool:\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for u, v in tasks:\n        graph[u].append(v)\n        in_degree[v] += 1\n    queue = [u for u in graph if u not in in_degree]\n    dp = [0] * (len(graph) + 1)\n    for i in range(1, len(graph) + 1):\n        dp[i] = max(dp[i - 1], dp[i - 1] + 1)\n        while queue:\n            u = queue.pop(0)\n            for v in graph[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    queue.append(v)\n    return dp[-1] == days", "solution_func": "def g(tasks=[('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'D'), ('D', 'E')]):\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for u, v in tasks:\n        graph[u].append(v)\n        in_degree[v] += 1\n    queue = [u for u in graph if u not in in_degree]\n    dp = [0] * (len(graph) + 1)\n    for i in range(1, len(graph) + 1):\n        dp[i] = max(dp[i - 1], dp[i - 1] + 1)\n        while queue:\n            u = queue.pop(0)\n            for v in graph[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    queue.append(v)\n    return dp[-1]", "description": "Find the solution: days (integer) that should represent the maximum number of levels in a topological sorting of the given tasks (list of tuples representing directed edges in a graph), such that each task is dependent on the previous one.", "unique_id": "aces_elm_s5_p339", "name": "puzzle_27"}
{"problem_func": "import math\n\ndef f(min_distance_to_origin: float, points=[(0, 0), (0, 1), (1, 0), (1, 1)]) -> bool:\n    def distance_to_origin(p):\n        return math.sqrt(p[0] ** 2 + p[1] ** 2)\n    def min_distance_to_origin_points(points):\n        min_distance = float('inf')\n        for p in points:\n            min_distance = min(min_distance, distance_to_origin(p))\n        return min_distance\n    return min_distance_to_origin == min_distance_to_origin_points(points)", "solution_func": "def g(points=[(0, 0), (0, 1), (1, 0), (1, 1)]):\n    def distance_to_origin(p):\n        return math.sqrt(p[0] ** 2 + p[1] ** 2)\n    def min_distance_to_origin_points(points):\n        min_distance = float('inf')\n        for p in points:\n            min_distance = min(min_distance, distance_to_origin(p))\n        return min_distance\n    return min_distance_to_origin_points(points)", "description": "Find the solution: min_distance_to_origin (a float) that should be the minimum distance from the origin (0, 0) to any point in the list of points (a list of 2D tuples), such that it equals the minimum distance calculated from the given points.", "unique_id": "aces_elm_s5_p2386", "name": "puzzle_28"}
{"problem_func": "def f(min_coins: int, amount=12, coins=[1, 2, 5, 10]) -> bool:\n    def min_coins_recursive(amount, coins, i, dp):\n        if amount == 0:\n            return 0\n        if amount < 0:\n            return float('inf')\n        if (amount, i) in dp:\n            return dp[(amount, i)]\n        min_coins = float('inf')\n        for j in range(i, len(coins)):\n            min_coins = min(min_coins, 1 + min_coins_recursive(amount - coins[j], coins, j, dp))\n        dp[(amount, i)] = min_coins\n        return min_coins\n    return min_coins == min_coins_recursive(amount, coins, 0, {})", "solution_func": "def g(amount=12, coins=[1, 2, 5, 10]):\n    dp = {}\n    def min_coins_recursive(amount, coins, i):\n        if amount == 0:\n            return 0\n        if amount < 0:\n            return float('inf')\n        if (amount, i) in dp:\n            return dp[(amount, i)]\n        min_coins = float('inf')\n        for j in range(i, len(coins)):\n            min_coins = min(min_coins, 1 + min_coins_recursive(amount - coins[j], coins, j))\n        dp[(amount, i)] = min_coins\n        return min_coins\n    return min_coins_recursive(amount, coins, 0)", "description": "Find the solution: min_coins (an integer) that should be the minimum number of coins from the list of coins (a list of integers) that sum up to the given amount (an integer), using each coin type at most once.", "unique_id": "aces_elm_s5_p1600", "name": "puzzle_29"}
{"problem_func": "def f(min_risk, investments=[(0.4, 10), (0.3, 20), (0.3, 30)], budget=100, min_return=50) -> bool:\n    risks = [0] * (len(investments) + 1)\n    for i in range(1, len(investments) + 1):\n        risks[i] = risks[i - 1] + investments[i - 1][0] * (1 - investments[i - 1][1] / min_return)\n    return risks[-1] == min_risk", "solution_func": "def g(investments=[(0.4, 10), (0.3, 20), (0.3, 30)], budget=100, min_return=50):\n    investments.sort(key=lambda x: x[1] / x[0], reverse=True)\n    min_risk = 0\n    for investment in investments:\n        min_risk += investment[0] * (1 - investment[1] / min_return)\n    return min_risk", "description": "Find the solution: min_risk (a float) that should be the minimum risk achievable by investing in a portfolio of investments (a list of tuples, where each tuple contains a risk and a return value) within a given budget (an integer) and meeting a minimum return requirement (an integer), such that the calculated risk of the portfolio equals min_risk.", "unique_id": "aces_elm_s5_p4397", "name": "puzzle_30"}
{"problem_func": "from typing import List\n\ndef f(teams: List[set], players=[(1, 2), (2, 3), (3, 4)], k=2) -> bool:\n    for team in teams:\n        skill_levels = [players[i][1] for i in team]\n        if not all(skill_levels[i] <= skill_levels[i + 1] for i in range(len(skill_levels) - 1)):\n            return False\n    return True", "solution_func": "def g(players=[(1, 2), (2, 3), (3, 4)], k=2):\n    teams = []\n    players.sort(key=lambda x: x[1])\n    for i in range(k):\n        team = set()\n        for j in range(i, len(players), k):\n            team.add(j)\n        teams.append(team)\n    return teams", "description": "Find the solution: teams (a list of sets of player indices) that should be divided into groups such that the skill levels of players within each team are in non-decreasing order, given a list of players (a list of tuples containing player index and skill level) and an integer k (not used in the function).", "unique_id": "aces_elm_s5_p893", "name": "puzzle_31"}
{"problem_func": "import math\ndef f(n: int, n_items=10, k=5) -> bool:\n    return n == k ** n_items", "solution_func": "def g(n_items=10, k=5):\n    import math\n    return k ** n_items", "description": "Find the solution: n (an integer) that should be equal to k raised to the power of n_items, where k is an integer and n_items is a positive integer.", "unique_id": "aces_elm_s5_p750", "name": "puzzle_32"}
{"problem_func": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_prime_factors(n):\n    i = 2\n    count = 0\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            count += 1\n    if n > 1:\n        count += 1\n    return count\ndef sum_binary(n):\n    return sum(int(digit) for digit in bin(n)[2:])\ndef max_prime_sum_dp(nums):\n    dp = [0] * (len(nums) + 1)\n    for i in range(1, len(nums) + 1):\n        for j in range(i):\n            if is_prime(nums[i - 1]) and sum_binary(nums[i - 1]) == count_prime_factors(nums[j - 1]):\n                dp[i] = max(dp[i], dp[j] + nums[i - 1])\n    return max(dp)\ndef f(max_prime_sum: int, nums=[10, 15, 20, 30, 45]) -> bool:\n    return max_prime_sum == max_prime_sum_dp(nums)\n", "solution_func": "def g(nums=[10, 15, 20, 30, 45]):\n    return max_prime_sum_dp(nums)", "description": "Find the solution: max_prime_sum (an integer) that should be the maximum sum of prime numbers in the list `nums` (a list of integers) where each prime number's binary sum equals the count of prime factors of another number in the list.", "unique_id": "aces_elm_s5_p1995", "name": "puzzle_33"}
{"problem_func": "import random\ndef f(max_successes, n=10, k=5, prob_dist=lambda x: 0.5 ** x) -> bool:\n    total_trials = 10000\n    success_trials = 0\n    for _ in range(total_trials):\n        heads = 0\n        for _ in range(n):\n            if random.random() < 0.5:\n                heads += 1\n        if heads == k:\n            success_trials += 1\n    return success_trials / total_trials * 100 >= max_successes\n\nimport random", "solution_func": "def g(n=10, k=5, prob_dist=lambda x: 0.5 ** x):\n    total_heads = 0\n    for _ in range(n):\n        if random.random() < 0.5:\n            total_heads += 1\n    return total_heads", "description": "Find the solution: max_successes (a percentage value) that should represent the minimum percentage of successful trials in which exactly k heads are obtained in n coin flips, such that the probability of obtaining heads in a single flip follows the given probability distribution prob_dist.", "unique_id": "aces_elm_s5_p4275", "name": "puzzle_34"}
{"problem_func": "def f(min_steps, str='abcba') -> bool:\n    def edit_distance(str1, str2):\n        m, n = len(str1), len(str2)\n        dp = [[0]*(n+1) for _ in range(m+1)]\n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                cost = 0 if str1[i-1] == str2[j-1] else 1\n                dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + cost)\n        return dp[m][n]\n    return edit_distance(str, str[::-1]) == min_steps", "solution_func": "def g(str='abcba'):\n    return 0", "description": "Find the solution: min_steps (an integer) that should be the minimum number of operations (insertions, deletions, or substitutions) required to transform the input string into its reverse, given the string 'abcba'.", "unique_id": "aces_elm_s5_p889", "name": "puzzle_35"}
{"problem_func": "import math\n\ndef f(min_cost, graph=[[0, 1, 1], [1, 0, 1], [1, 1, 0]]) -> bool:\n    def find_min_cost(graph, current_node, visited, current_cost):\n        if len(visited) == len(graph):\n            return current_cost\n        min_cost_so_far = math.inf\n        for i in range(len(graph)):\n            if i not in visited and graph[current_node][i] != 0:\n                min_cost_so_far = min(min_cost_so_far, find_min_cost(graph, i, visited + [i], current_cost + graph[current_node][i]))\n        return min_cost_so_far\n    return min_cost == find_min_cost(graph, 0, [0], 0)", "solution_func": "def g(graph=[[0, 1, 1], [1, 0, 1], [1, 1, 0]]):\n    min_cost = math.inf\n    for i in range(len(graph)):\n        for j in range(i + 1, len(graph)):\n            if graph[i][j] != 0:\n                min_cost = min(min_cost, graph[i][j])\n    return min_cost", "description": "Find the solution: min_cost (an integer) that should be the minimum total cost of traversing all nodes in the graph (a 2D list of integers) exactly once and returning to the starting node, where the cost of traversing from one node to another is given by the corresponding value in the graph.", "unique_id": "aces_elm_s5_p3949", "name": "puzzle_36"}
{"problem_func": "import math\n\ndef f(max_value, items=[(3, 60, 5), (2, 100, 7), (1, 120, 11)], capacity=5) -> bool:\n    dp = [0] * (capacity + 1)\n    for item in items:\n        for i in range(capacity, item[0] - 1, -1):\n            dp[i] = max(dp[i], dp[i - item[0]] + item[1])\n    return dp[capacity] == max_value", "solution_func": "def g(items=[(3, 60, 5), (2, 100, 7), (1, 120, 11)], capacity=5, max_value=220):\n    return max_value", "description": "Find the solution: max_value (an integer) that should be the maximum total value that can be put in a knapsack of capacity (an integer) by selecting items (a list of tuples, each containing the weight, value, and another attribute of an item) in such a way that the total weight does not exceed the capacity.", "unique_id": "aces_elm_s5_p1923", "name": "puzzle_37"}
